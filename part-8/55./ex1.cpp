// this : 이것 -> 객체에서 자기 자신을 가리킬 때 사용하는 포인터

#include <iostream>

using namespace std;

/*
class MyClass {
public:
    void PrintThis()
    {
        cout << "나의 주소는 " << this << endl; // 함수 내부의 this = 해당 함수가 소속된 객체의 주소
    }
};

int main()
{
    MyClass a, b;

    cout << "a의 주소는 " << &a << endl; // 16진법 주소가 출력됨
    cout << "b의 주소는 " << &b << endl;

    a.PrintThis(); // a의 주소가 출력됨
    b.PrintThis(); // b의 주소가 출력됨
}
*/

// a, b 객체가 실제 메모리 상에 저장됨
// -> 흔히들, 객체 내부의 PrintThis 함수가 객체마다 따로 저장될 것이라고 생각함
// -> 하지만, 함수도 결국 메모리에 저장되기 때문에, 함수마다 따로 포인터가 있음
// -> 상식적으로 생각해봤을 때, 메모리 상에서 함수가 차지하는 공간이 변수가 차지하는 공간보다 더 클 것임
// -> 객체가 생성될 때마다 매번 같은 함수를 메모리에 저장하면, 메모리가 그만큼 낭비될 것임
// -> 때문에, 객체마다 함수를 저장하지 않음 -> 함수는 객체 외부에 따로 저장됨
// -> 임의의 객체에서 함수가 호출되면, 다른 위치에 저장되어 있던 함수가 호출됨
// -> 함수 입장에서는 자신을 호출한 객체의 주소를 알 방법이 없음

// this 가 없다고 가정해보면, 이런 넌센스한 상황을 타개할 수 있음
// -> 함수에서 this 포인터 없이 객체의 주소를 알아낼 방법에 대해 생각해보면 됨
// -> 아래처럼, 매개 변수로 객체의 주소를 넘겨줬다고 생각해볼 수 있음

class MyClass {
public:
    void PrintThis(MyClass* ptr) // 객체의 주소가 인자로 들어옴
    {
        cout << "나의 주소는 " << ptr << endl;
    }
};

// 매개 변수를 따로 받지 않는 이유
// -> 보이지 않는 매개 변수가 하나 있다고 생각하면 됨
// -> 클래스나 구조체 내부에 선언된 함수들은, 모두 보이지 않는 매개 변수를 통해 this 라는 이름의 포인터를 전달받음

/*
정리)
    - this == 매우 유용한 포인터, 보이지 않는 매개 변수
    - 클래스 내부에서 선언된 함수 -> 객체마다 따로 저장되지 않고, 아예 별도의 공간에 저장됨
                                  -> 대신, this 라는 포인터를 매개 변수로 받아, 자신을 호출한 객체(소속) 를 확인함
*/

int main()
{
    MyClass a, b;

    cout << "a의 주소는 " << &a << endl;
    cout << "b의 주소는 " << &b << endl;

    a.PrintThis(&a); // 인자로 주소를 직접 넘겨주기
    b.PrintThis(&b);
}
