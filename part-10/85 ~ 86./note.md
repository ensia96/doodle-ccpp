이번 시간에는 코드보다는 이론 위주로 살펴볼 것임

지난 시간까지, 객체 지향 프로그래밍에 관련된 여러 주제들을 다뤘음

이번 시간에는 그러한 객체 지향이 의미하는 바를 정리해볼 것임

===========================================================================================================================

객체 지향 프로그래밍(Object-Oriented Programming, OOP) 의 4대 원리(원칙, 특성, 특징)

1. 캡슐화 54강 (Encapsulation) (클래스 내 추상화)
    무엇    - 자료(멤버 변수) 와 기능(멤버 메서드) 을 하나의 단위로 묶어 놓음
            - 자료를 보이지 않게 가리고, 자료에 접근하기 위한 메서드만을 노출 (정보 은닉)
    언제    - 언제든!
    왜      - 클래스 사용자 : 클래스 내부 구조 이해 x, 사용법만 알면 사용 가능
                              자료를 실수로 잘못 바꾸는 것을 방지
    어떻게  - 클래스 안에 멤버 변수, 멤버 메서드 선언 / 접근 제어

    class TV { 볼륨, 채널 등의 멤버 변수 + get/set 함수 등의 멤버 메서드 } 를 예시로 살펴봤음
    -> 멤버 변수와 멤버 메서드를 하나의 클래스로 묶는 것 = data bundling
    -> 외부에서 멤버 변수에 접근하는 것을 제한하고, 접근 수단만 제공하는 것 = information hiding
    -> encapsulation = (data bundling) or (information hiding) or (data bundling + information hiding)

    information hiding = 정보 은닉, 어떤 정보를 숨기는 것
    -> 접근 제어 지시자(public, private 등) 활용
    -> 멤버 변수의 공개 수준은 private 으로 지정하고, get/set 메서드만 public 수준으로 공개

    캡슐화로 생기는 이점 : 메서드 사용법만 알아도 클래스를 사용할 수 있음 (클래스 내부 구조를 몰라도 됨)

    자동차 예시
    -> 자동차 구조를 몰라도, 운전할 줄만 알면 자동차를 몰 수 있음
    -> 물론, 구조를 알면 더 안전하고 효율적으로 자동차를 몰 수 있긴 함
    -> 운전대, 페달, 기어를 어떻게 다뤄야 하는지만 알아도 충분함
    -> 자동차에 대해 잘 모르는 운전자가 자동차 부품을 막 바꾸면, 문제가 생길 수 있음
    -> 운전에 불필요한 부분들은 운전자로부터 격리시켜 두는 것이 좋음

    캡슐화는 하면 할수록 좋음
    - 도구        : 어떤 목적을 달성하는 데에 사용할 수 있는 물건
    - 도구의 특징 : 동작 원리를 몰라도 사용법만 알면 사용할 수 있음
    - 인간        : 그러한 도구를 사용하는 것에 매우 익숙해져 있음
    - 캡슐화      : 객체를 도구처럼 사용할 수 있게 됨 (메서드 == 사용법)

2. 상속성 75강 (Inheritance)
    무엇    - 부모 클래스의 멤버를 재사용해서 자식 클래스에서도 사용할 수 있음
    언제    - 부모 클래스에서 할 수 있는 일을 자식 클래스에서도 할 수 있다 (Liskov 치환 원칙)
            - 자식 클래스는 부모 클래스의 일종이다 (A is a B)
    왜      - 코드 재사용
    어떻게  - 상속!

    동물과 새 예시
    -> 동물이 할 수 있는 일을 새도 할 수 있다고 가정
    -> 이럴 때, 동물은 부모, 새는 자식이 되도록 모델링할 수 있음

    '언제' 항목의 첫 번째 내용을 만족하면, 보통은 두 번째 내용도 만족하게 됨
    -> 두 번째 내용만 신경 쓰면, 상속 관계를 계층 관계로만 생각하게 됨 (상속 관계가 꼬일 수 있음)
    -> 첫 번째 내용을 만족하는지를 확인해보면 상속 관계를 제대로 정의할 수 있음
    -> 더 자세한 내용이 궁금하다면, 'Liskov 치환 원칙' 을 찾아보길 권장함

3. 다형성 78강 (Polymorphism)
    무엇    - 동적 다형성 : 한 클래스가 그로부터 파생된 다양한 형태를 지닐 수 있음
            - 정적 다형성 : 함수 오버로딩, 템플릿
    언제    - 자식 클래스의 메서드 구현이 부모 클래스와 다를 때
    왜      - 자식 클래스에서 하고 싶은 일들이 부모 클래스에서와 다를 수 있음
    어떻게  - 오버라이딩, 가상 함수!! (RTTI, 다형적 클래스)

    Shape, Circle, Rectangle 예제
    -> 도형의 넓이를 반환하는 GetArea() 메서드가 있었음
    -> 원의 넓이를 구하는 방식과 직사각형의 넓이를 구하는 방식이 다름
    -> 오버라이딩을 통해, 같은 메서드가 클래스에 따라 다르게 동작하도록 구현할 수 있음
    -> 오버라이딩된 함수가 실행되기 위해선 동적바인딩이 일어나야 함
    -> Shape* s1 = new Circle; Shape* s2 = new Circle; 모두 가능
    -> Shape 포인터가 가리키고 있는 대상에 따라, s->GetArea() 가 다르게 동작함

    GetArea() 메서드는 Shape 클래스에서는 아무 역할도 하지 않음
    -> 하지만, Shape 클래스의 자식 클래스인 Circle, Rectangle 클래스에서는 각각 고유한 역할을 수행함
    -> 어떤 메서드가 자식 클래스에 따라 다르게 동작하는 경우, 그 메서드가 다형성을 지닌다고 함

    가상 함수가 없으면 동적 바인딩이 일어나지 않음 + RTTI 기능도 사용 불가능

    다형성 개념을 두 가지로 나눠서 생각하는 사람도 있음
    -> 크게 정적 다형성, 동적 다형성으로 나뉨
    -> 오버로딩된 함수는 주어진 인자에 따라 다르게 동작함
    -> 실행 시간에 변화가 생기지는 않기 때문에 정적 다형성을 지닌다고 할 수 있음
    -> 아직 배우진 않았지만, 템플릿이라는 개념도 정적 다형성을 지님
    -> 일반적인 상황에서 다형성이라 하면, 동적 다형성을 뜻하는 경우가 대부분

4. 추상화 80강 (Abstraction) (클래스 간 추상화)
    무엇    - 부모 클래스 : 클래스가 구현해야 할 기능만을 명시 (순수 가상 함수)
            - 자식 클래스 : 실제 구현
    언제    - [자식 클래스]는 [부모 클래스]할 수 있어야 한다. (A is able to B)
    왜      - "자동차" : 운전대, 페달, 기어 변속기 (추상 클래스)
            - 각 부품의 작동 원리는 자동차 종류마다 다름
    어떻게  - 추상 클래스 (순수 가상 함수)

    부모 클래스에서는 클래스가 구현해야 할 기능만 명시하고, 실제 기능은 자식 클래스에서 구현하는 것
    -> 부모 클래스에 순수 가상 함수를 만들어 두고, 자식 클래스에서 오버라이딩하는 것
    -> 이럴 때, 부모 클래스에 선언된 순수 가상 함수를 '자식 클래스의 메서드를 추상화한 요소' 라고 할 수 있음

    A는 B할 수 있어야 한다. (Shape 예시)
    -> GetArea(), Resize() 메서드는 Shape 클래스에서는 아무 역할도 하지 않음
    -> 그래서, GetArea() 와 Resize() 를 순수 가상 함수로 만들어 줌
    -> Shape 클래스가 순수 가상 함수를 포함하는 추상 클래스가 됨 (Shape 객체 생성 불가)
    -> 추상 클래스는 클래스가 구현해야 할 기능을 명시하기 위해 존재함
    -> GetArea(), Resize() 메서드는 파생 클래스들의 특성에 맞게 따로 구현됨
    -> Shape 클래스의 자식 클래스는 GetArea(), Resize() 할 수 있어야 한다.
    -> 이렇게 추상 클래스의 자식이 되기 위한 조건을 명시해주는 것임
    -> 파생 클래스는 그러한 조건을 따름과 동시에 자신의 특성에 맞게 순수 가상 함수를 오버라이딩함

    자동차 예시
    -> 자동차는 추상 클래스가 됨 (자동차는 ~해야 한다는 것을 정의)
    -> 파생 클래스들은, 세부적으로는 다르게 구현되지만, 자동차 클래스에 정의된 기본 사양을 따름
    -> 이것이 클래스 개념을 추상화하는 이유임
    -> 파생 클래스마다 이러한 사양들은 모두 다르게 구현됨
    -> 추상 클래스에 명시된 인터페이스만 알아도, 파생 클래스의 객체를 사용할 수 있음
    -> 어느 정도는 캡슐화의 성격을 띤다고 볼 수도 있음

    캡슐화는 클래스 내부적으로 일어나는 추상화, 추상화는 클래스 간에 일어나는 추상화로 볼 수 있음

    -> 캡슐화는 어떤 클래스 하나에 대해서만 적용할 수 있는 개념임
    -> TV는 내부 구성을 몰라도, 볼륨을 조절하거나 채널을 바꾸거나 전원을 켜고 끌 수 있음
    -> 이렇게, 추상적인 인터페이스만을 제공하도록 클래스를 설계하는 것이 캡슐화임
    -> TV라는 클래스(추상적인 형태, type) 를 기반으로, 여러 객체를 만들 수 있음
    -> 이 때, 'TV 클래스에서 제공하는 추상적인 인터페이스' 를 활용해 TV 객체를 사용할 수 있음
    -> 클래스에 대한 캡슐화를 클래스 자체에 대한 추상화로 볼 수 있음

    -> 클래스 간 추상화는 한 클래스가 아닌 여러 클래스에 대해서 추상화를 하는 것임
    -> 'L사 TV', 'S사 TV' 등, 여러 종류의 TV가 있을 수 있음
    -> 두 TV는 내부 구성이 완전히 다르지만, 사용자는 두 TV를 모두 비슷한 방식으로 사용할 수 있음
    -> 볼륨 조절이나 채널 변경, 전원 조작 등 TV의 인터페이스를 두 TV에서도 사용할 수 있기 때문
    -> TV 클래스의 경우, 내부에 순수 가상 함수를 정의해두고, 그 요소들을 인터페이스로써 제공함
    -> 'L사 TV', 'S사 TV' 등의 파생 클래스에서는 TV 클래스에 정의된 순수 가상 함수를 오버라이딩함
    -> 오버라이딩을 통해 추상적으로 설계된 인터페이스에 맞춰 실제 기능을 구현하는 것
    -> 사용자는 TV에 대한 인터페이스만 알고 있어도, 모든 TV 사용 가능 (추상화되어있기 때문)
