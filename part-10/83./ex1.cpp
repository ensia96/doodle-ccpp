// 지난 시간에는 파생 클래스에서 기반 클래스로 바뀌는 형 변환인 업캐스팅에 대해서 알아봤음
// -> 업캐스팅과는 반대로, 다운 캐스팅은 기반 클래스에서 파생 클래스로 바뀌는 형 변환임

// 다운캐스팅을 일으키는 수단은 크게 두 가지가 있음
// static_cast, dynamic_cast

// 이번 시간에는 다운캐스팅의 개념과 함께 static_cast 위주로 알아볼 것임
// -> dynamic_cast 에 대해서는 다음 시간에 자세히 알아볼 것임

// static_cast == 정적으로(컴파일 시간에) 형 변환을 일으키는 것
// -> 대표적으로, double -> int / int -> double / 업캐스팅 / 다운캐스팅 등이 있음

#include <iostream>

using namespace std;

class Base {
public:
    int a = 1;
};

class Drv1 : public Base {
public:
    void f()
    {
        cout << "Drv1::f()" << endl;
        cout << b << endl;
    }

    float b = 3.14;
};

class Drv2 : public Base {
public:
    void f()
    {
        cout << "Drv2::f()" << endl;
        cout << c << endl;
    }

    int c = 3;
};

int main()
{
    /*
    Base* b = new Drv1; // Base 클래스에 대한 포인터 b로, 파생 클래스인 Drv1 의 객체를 가리키고 있는 상황
                        // -> b를 통해 접근할 수 있는 것은 Base 클래스에서 선언된 멤버들 뿐임 (b->a;)
                        // -> Drv1 클래스의 멤버에 접근할 수 있게 할 방법이 필요한 것
    */
    /*
    Base* b = new Drv1;
    Drv1* d1 = b; // b에는 주소값만 저장되어 있으니, 다른 포인터에 그 주소값을 대입해볼 수도 있음
                  // -> 이러한 대입 연산이 가능하면, d1을 통해 Drv1 클래스의 멤버에 접근할 수 있을 것임 (d1->f();)
                  // -> C, C++ 에서는, 기본적으로는, 서로 다른 타입의 포인터끼리는 대입 연산이 불가능함
                  // -> 기반 클래스 포인터에 파생 클래스 포인터를 대입하는 경우는 가능함 (업캐스팅)
                  // -> 하지만, Drv1* d1 = b; 의 경우, 다운캐스팅이 일어나야함
                  // -> C++ 에서는 다운캐스팅이 자동으로 일어나는 것을 허용하지 않음
                  // -> 때문에, 무조건 명시적으로 형 변환을 해줘야 함
    */
    /*
    Base* b = new Drv1;
    Drv1* d1 = (Drv1*)b; // 이렇게 직접적으로 형을 변환해주는 것이 가장 원초적인 방법
                         // -> b에 있던 주소값은 그대로 유지한 채로, 자료형만 바뀌게 됨
                         // -> 가리키는 대상의 자료형만 바꾸는 식으로 다운캐스팅을 해준 것임
    */
    /*
    Base* b = new Drv1;
    int* a = new int(5);
    Drv1* d1 = (Drv1*)a; // 분명히 잘못된 코드인데도 오류가 안 뜸
                         // -> C++ 에서는, 이런 실수를 해도 막을 수단이 없음
                         // -> 경우에 따라서는 런타임 에러가 발생할 수도 있음
                         // -> 컴파일 시간에 형 변환 코드에 문제가 있는지 검사할 방법이 필요함
                         // -> 그렇게 등장한 것이 static_cast 임
                         // -> C 언어에서의 명시적 형 변환과 비슷함
    */
    /*
    Base* b = new Drv1;
    Drv1* d1 = static_cast<Drv1*>(a); // 이렇게 static_cast 를 활용하면, 정상적으로 오류가 뜸
                                      // -> 이렇게 잘못된 형 변환을 제외하면, 거의 모든 형 변환이 가능
    */
    /*
    Base* b = new Drv1;
    Drv1* d1 = static_cast<Drv1*>(b); // 이렇게 작성하면 오류가 안 뜸 (평범한 다운캐스팅이기 때문)
    d1->f();
    */

    // 아쉽게도, static_cast 에는 문제점이 있음
    // -> 문법적으로는 해결할 수 없음 (코딩하는 사람이 신경 써야함)

    // Base* b = new Drv2;            // 이렇게 작성되어 있으면 잘 동작함
    Base* b = new Drv1;               // 이렇게 작성되어 있으면 문제가 됨
                                      // -> 컴파일러는 b 포인터가 가리키고 있는 객체가 어떤 클래스의 객체인지 모름
    Drv2* d2 = static_cast<Drv2*>(b); // 컴파일러는 b가 Drv2* 로 변환될 수 있는지만 확인함
                                      // -> static_cast<Drv1*>(b) 로 작성해도 오류가 뜨진 않음
                                      // -> 컴파일러 입장에서는 전혀 문제가 없는 문장이기 때문
                                      // -> 실행은 제대로 되지만 결과가 이상하게 나옴
    d2->f();

    // Base* b 는 Drv1 객체를 가리키고 있음
    // -> static_cast<Drv2*> / Base -> Drv2 / 다운캐스팅이 일어남
    // -> Drv2 포인터로 Drv1 객체를 가리키고 있는 상태
    // -> 컴파일러는 d2 포인터가 가리키는 대상을 Drv2 객체로 인식
    // -> new Drv1 에서 생성된 객체는 멤버 a, b가 저장될 수 있을 만큼의 공간을 차지함
    // -> f() 메서드는 객체 내부가 아닌 별도의 공간에 저장됨 (=> void f(this) { ... })
    // -> 실제 객체(new Drv1) 에는 1과 3.14가 나란히 저장되어 있는 상황 (=> {1, 3.14})
    // -> Drv2 객체에는 1과 3.14가 아닌, 1과 3이 저장되어 있음 (=> {1, 3})
    // -> d2->f() 를 실행하면, 함수 내부의 c가 호출됨 (this->c)
    // -> 컴파일러는 객체에 저장된 정보가 실제로 어떤 정보인지 모름
    // -> new Drv1 객체를 Drv2 객체로 보고, c가 저장되어 있어야 할 위치를 확인함
    // -> 그 위치에는 2진수 형태로 저장된 3.14가 있을 것임
    // -> 컴파일러는 그 2진수 형태의 3.14를 int 자료형으로 취급해서 출력함 (1078523331)

    // static_cast 를 사용해 다운캐스팅을 일으킬 때는, 대상의 자료형을 제대로 확인해줘야함
    // -> 컴파일 시간에 오류가 나진 않지만, 실행 시간에 오류가 날 수 있음
    // -> 이렇게, 의도했던 데로 동작하지 않게 될 수 있음

    // 포인터가 가리키는 대상의 자료형을 알기 힘든 상황도 분명 존재함
    // -> 위에서 살펴봤듯, 포인터가 가리키고 있는 객체의 자료형과 다운캐스팅될 자료형이 다를 수 있음
    // -> 이 때, 포인터가 가리키고 있는 객체의 자료형을 실행 시간에 알 수 있는 방법이 있다면 좋을 것임
    // -> 그런 방법이 있다면, 실행 시간에 문제가 생겨도, 그 문제에 대해 적절하게 처리해줄 수 있을 것임
    // -> 다음 시간에 배울 dynamic_cast 로 가능함

    delete b;
}
