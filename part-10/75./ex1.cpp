// C++ 에서 가장 중요한 내용이라고 할 수 있는 객체 지향 프로그래밍에 대해 본격적으로 알아볼 것임
// -> 지금까지 배운 동적 할당, 복사/이동 개념도 객체 지향적인 요소들이긴 함
// -> 객체 지향 프로그래밍에서 가장 중요한 개념 중 하나인 상속에 대해서 알아볼 것임
// -> 상속을 하기 위해 객체를 사용했다고도 할 수 있을 정도로 중요한 개념임

// 상속 : 물려주는 것 (부모가 자식에게 재산 등을 물려주는 것)
// -> 부모와 자식이 각각 누구인지와 무엇을 물려주는지가 중요함
// -> 부모 클래스와 자식 클래스가 있다고 가정
// -> 부모 클래스가 자식 클래스에게 물려줄 수 있는 요소에는 멤버 메서드, 변수 등이 있을 것임
// -> 자식에게 물려준다고 해서, 부모 클래스에서 상속한 요소들이 사라지는 것은 아님
// -> 부모의 멤버들을 자식도 사용할 수 있게 됨 + 자식도 자기 자신만의 멤버들을 가질 수 있음

// 자식 클래스가 부모 클래스에 포함되는 것일까, 부모 클래스가 자식 클래스에 포함되는 것일까?
// -> 잘 모르는 상태에서 보면, 부모 클래스가 자식 클래스에 포함된다고 생각할 수도 있음
// -> 부모 클래스의 모든 멤버가 자식 클래스에 포함되어 있고, 자식 클래스에는 부모 클래스에 없는 멤버도 있기 때문
// -> 사실은 정반대임

// 남자와 총각을 예로 살펴보자.
// -> 남자는 사람이면서, Y 염색체를 가지고 있어야 함
// -> 총각은 사람이면서, Y 염색체를 가지고 있어야하고, 성인이면서, 미혼이어야 함
// -> 남자가 총각에 포함될까, 총각이 남자에 포함될까? 라고 물으면, 당연히 총각이 남자에 포함된다고 답할 것임
// -> 물론, 남자이기 위한 조건은 총각이 되기 위한 조건에 포함되어 있음
// -> 이렇게, 개념 사이의 포함 관계와 개념 성립 조건 사이의 포함 관계는 서로 반대임 (직관적이진 않은 편)

// 자신의 멤버를 다른 클래스에게 물려주는 방법에 대해 살펴볼 것임

#include <iostream>

using namespace std;

class Base { // 부모 클래스 이름은 보통, Base 로 지정함
             // -> 기반이 되는 클래스가 있고, 거기에 어떤 요소들이 추가된 새로운 클래스가 파생되는 식임
             // -> 기반 클래스(Base), 파생 클래스(Derived)
public:
    // 편의상, 모든 멤버를 public 으로 지정
    void bFunc()
    {
        cout << "Hello!" << endl;
    }

    int bNum;
};

class Derived : public Base { // 이렇게 옆에 콜론과 함께 상속받을 클래스를 지정해주면 됨 (public 을 적는 이유는 나중에)
                              // -> Base 를 부모로 하는 자식 클래스라는 의미
                              // == Base 클래스에서 파생된 클래스
                              // == Base 클래스의 멤버를 상속받은 클래스
public:
    void dFunc()
    {
        cout << "Hello?" << endl;
    }

    int dNum;
};

int main()
{
    Base b;
    Derived d;

    b.bFunc();
    b.bNum = 1;
    // b.dFunc(); // 이렇게는 안 됨 (부모 클래스에서는 자식 클래스의 고유한 멤버에 접근할 수 없기 때문)

    d.bFunc(); // 자기 자신이 갖고 있는 고유한 멤버 외에, 부모 클래스에 있는 멤버에도 접근 가능
    d.bNum = 2;
    d.dFunc();
    d.dNum = 3;
}
